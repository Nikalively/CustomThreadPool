# CustomThreadPool

## Описание
Этот проект реализует пользовательский пул потоков  с настраиваемым управлением очередями, логированием, параметрами и политикой отказа для высоконагруженных серверных приложений.  

## Основные компоненты:

- Интерфейс `ThreadPool` (похожий на `Executor`)
- Класс `DefaultThreadPool` с Round-Robin распределением задач по нескольким очередям
- `ThreadWorker` — рабочие потоки с учётом `keepAliveTime` и `minSpareThreads`
- `PoolThreadFactory` — фабрика с логированием создания потоков
- Две политики отказа: `AbortPolicy`, `CallerRunsPolicy`
- Поддержка `submit(Callable) → Future`

## Ключевые возможности
- Настраиваемые параметры пула:
    - `corePoolSize` – минимальное число потоков, всегда живых
    - `maxPoolSize` – верхний предел потоков
    - `keepAliveTime` + `TimeUnit` – время простоя сверх `corePoolSize`
    - `queueSize` – размер каждой очереди задач
    - `minSpareThreads` – резерв свободных потоков
- Round-Robin распределение задач по N очередям
- Авто-масштабирование:
    - при низком числе простаивающих потоков (‹ `minSpareThreads`) добавляются новые
    - при переполнении очереди и `currentPoolSize < maxPoolSize` добавляется новый воркер
- Политики отказа:
    - `AbortPolicy` – бросает `RejectedExecutionException`
    - `CallerRunsPolicy` – выполняет задачу в вызвавшем потоке
- Graceful shutdown:
    - `shutdown()` – пул перестаёт принимать новые задачи, но завершает уже принятые
    - `shutdownNow()` – прерывает воркеры сразу
- Поддержка `submit(Callable<T>)` с возвратом `Future<T>`
- Логирование через SLF4J + Logback:
    - создание/запуск/завершение потоков
    - приём и выполнение задач
    - события отказа и тайм-аута  

## Структура проекта
```plaintext
CustomThreadPool
├── pom.xml              # Maven-конфигурация
└── src/
├── main/
│   ├── java/
│   │   └── com/example/threadpool/
│   │       ├── ThreadPool.java
│   │       ├── DefaultThreadPool.java
│   │       ├── ThreadWorker.java
│   │       ├── PoolThreadFactory.java
│   │       ├── RejectedPolicy.java
│   │       ├── AbortPolicy.java
│   │       ├── CallerRunsPolicy.java
│   │       └── Demo.java
│   └── resources/
│       └── logback.xml  # Конфиг Logback
└── README.md            # Описание проекта
```
## Демонстрационное тестирование
В Demo.java пул запускается с параметрами:
```
corePoolSize    = 2
maxPoolSize     = 5
keepAliveTime   = 5 секунд
queueSize       = 10
minSpareThreads = 1
RejectedPolicy  = new AbortPolicy()
```
Demo отправляет 20 задач (по 500 ms сна внутри каждой).

## Результаты демо (20 задач по 500 ms)

**Результаты демо (20 задач по 500 ms)**

| Показатель                 | Значение |
|----------------------------|----------|
| Всего задач                | 20       |
| Выполнено задач            | ~20      |
| Отклонено задач            | 0        |
| Время выполнения демо (s)  | ~8       |

При повышении нагрузки (50–100 задач) становятся заметны отказ и масштабирование.

**Пример бенчмарка**
Настройки (ThreadPoolBenchmark.java):
1. Отправляет 200 задач с паузой 10 ms
2. Замеряет общее время, число выполненных и отклонённых задач

| Метрика                       | CustomThreadPool | ThreadPoolExecutor |
|-------------------------------|------------------|--------------------|
| Общее время (ms)              | 1600             | 1550               |
| Выполнено задач               | 75               | 55                 |
| Отклонено задач               | 125              | 145                |
| Среднее время на задачу (ms)  | 21.3             | 28.2               |

**Мини-исследование параметров (queueSize)**

| queueSize | Выполнено | Отклонено | Среднее (ms) |
|-----------|-----------|-----------|--------------|
| 5         | 50        | 150       | 0.20         |
| 10        | 110       | 90        | 0.10         |
| 25        | 180       | 20        | 0.06         |
| 50        | 200       | 0         | 0.05         |

 **Вывод:** при `queueSize = maxPoolSize * 2` достигается оптимальный баланс между отказами и задержками.  

## Принцип работы

1. **Round-Robin**  
   Счётчик `nextQueue` последовательно выбирает очередь от `0` до `N–1`.

2. **Авто-масштабирование**
    - Если `idleThreads < minSpareThreads` → создаётся новый поток (до `maxPoolSize`).
    - Если очередь полна **и** `currentPoolSize < maxPoolSize` → добавляется новый воркер и задача перенаправляется.

3. **Таймаут и завершение**
    - Воркер ждёт задачу методом
      ```
      queue.poll(keepAliveTime, timeUnit)
      ```  
    - Если возвращается `null` **и** `currentPoolSize > corePoolSize` → воркер завершает себя.

4. **Shutdown**
    - `shutdown()` — пул перестаёт принимать новые задачи, но обрабатывает уже принятые.
    - `shutdownNow()` — пул прерывает все воркеры сразу.